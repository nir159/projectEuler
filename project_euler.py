"""
challenges at https://projecteuler.net/
UserName: EulerPoint
"""

import math
import helper
import strings

# find sum of all multiples of 3 and 5 from 1 to 1000
def multiples():
    sum = 0
    for i in range(3, 1000, 3):
        sum += i
    for i in range(5, 1000, 5):
        if i%3 != 0:
            sum += i
    return sum

    
# returns the sum of all even terms in a fib sequence up to 4 million
def even_fib():
    a = 1
    b = 2
    limit = 4000000
    even_sum = 2
    while a < limit and b < limit:
        a,b = b,a + b
        a = a + b
        if a%2 == 0:
            even_sum += a
        if b%2 == 0:
            even_sum += b
        b,a = a,a + b
        b = a + b
        if a%2 == 0:
            even_sum += a
        if b%2 == 0:
            even_sum += b
    return even_sum

# return true if num is prime
def is_prime(num):
    if num == 2:
        return True
    if num%2 == 0:
        return False
    
    for i in range(3, int(math.sqrt(num))+1):
        if num%i == 0:
            return False
    return True

# find the largest prime factor of a number
def largest_prime_factor(num):
    if num%2 == 0:
        return num/2
    sqroot = int(math.sqrt(num))
    if sqroot%2 == 0:
        sqroot += 1
    for i in range(sqroot, 2, -2):
        if num%i == 0 and is_prime(i):
           return i
           
           
# determines if a number is a palindrom
def is_palindrom(string):
    for a,b in zip(string[:int(len(string)/2)+1],string[-1:int(len(string)/2)-1:-1]):
        if a != b:
            return False
    return True
    
    
    
    
# function will return the largest palindrom made
# from the product of two 3-digit numbers
def three_digit_palindrom():
    max = 0
    for a in range(999, 99, -1):
        for b in range(999, 99, -1):
            if a*b > max and is_palindrom(str(a*b)):
                max = a*b
    return max
       




# find the smallest number that is devided by all numbers from 1 to n
def smallest_divider_upto(n):
    # WARNING: BAD PRACTICE
    """i = 232792560
    while True:
        for j in range(2, 21):
            if i%j != 0:
                break
            if j == 20:
                return i
        i += 20"""
    # task making sure the gcd stays 1 always
    # therefore removing all unnecessary primes
    ans = 1
    for i in range(1, n + 1):  
        ans = int((ans * i)/math.gcd(ans, i))          
    return ans
       
       
# returns the difference between the sum of the squares of the first n natural numbers and the square of the sum.
def squares_sum_difference(n):
    # sum of squares:
    squares_sum = n*(n+1)*(2*n+1)//6

    # square of sum:
    sum_square = ((1 + n)*n//2)**2
    
    return sum_square - squares_sum
    
   
# find the n prime number
def nth_prime_number(n):
    prime_list = [2]
    num = 3
    while len(prime_list) < n:
        for p in prime_list: # check if num is divided by primes generated
            if num % p == 0:
                break

        else:
            prime_list.append(num)
        num += 2
        
    return prime_list[-1]


# returns the greatest product of n elements in a random digits string
# n = 4  - 9989 9*9*8*9
def adjacent_highest_sum(n):
    random_number = strings.ADJACENT_HIGHEST_SUM
    random_number = random_number.replace('\n', '')
    random_number = random_number.replace(' ', '')
    max = 0
    for i in range(len(random_number)):
        if i+n-1 > len(random_number)-1:
            return max
        print(i)
        product = 1
        for j in range(n):
            product *= int(random_number[i+j])
        if product > max:
            max = product
    
    
# returns product of pythagoras triplet that sums to 1000
"""
a + b + c = 1000
a < b < c
a^2 + b^2 = c^2
aa + bb = cc

a + b + (a**2 + b**2)**0.5 = 1000

All Pythagorean triples can be generated by these formulas 
where m and n are any positive integers with m > n

a = m^2 - n^2

b = 2mn

c = m^2 + n^2

The sum of these is

a + b + c = 2m^2 + 2mn = 2m (m + n) = 1000
2m (m + n) = 1000
m (m + n) = 500

500 subdivision = 20,25 -> 20,20+5
m = 20
n = 5

a = 400 - 25 = 375

b = 200

c = 400 + 25 = 425
"""
def pythagoras_product():
    while True:
        for b in range(375,400):
            for a in range(200, b):
                if a + b + (a**2 + b**2)**0.5 != 1000:
                    print(a,b)
                    continue
                c = (a**2 + b**2)**0.5
                print(a,b,c)
                return a*b*c
    
    

# returns the sum of primes up to n
def sum_of_primes(n):
    # optimal way of getting list of primes
    indexes = [True] * n
    for i in range(3,int(n**0.5)+1,2):
        if indexes[i]:
            """
            3*3 - not prime
            3*3 + 3*2
            3*(3+2) - not prime
            3*3 + 3*2 + 3*2....
            """
            # removing all odd numbers that are not primes by removing all possible occurrences
            indexes[i*i::2*i]=[False]*((n-i*i-1)//(2*i)+1)
    return sum([2] + [i for i in range(3,n,2) if indexes[i]])  # ignoring all even numbers



# returns the greatest product of 4 adjacent numbers in the same direction
def adjacent_direction_highest_product():
    random_number = strings.ADJACENT_DIRECTION_HIGHEST_SUM
    random_number = random_number.replace('\n', '')
    random_number = random_number.replace(' ', '')
    max = 0
    for i in range(0, len(random_number), 2):
        
        right_possible = False
        left_possible = False
        down_possible = False
        # no need to check up if you check down
        
        if i+1+3*2 < len(random_number)-1 and (i+6) % 40 > i % 40:
            right_possible = True
            product = 1
            for j in range(0, 8, 2):
                product *= int(random_number[i+j] + random_number[i+j+1])
            if product > max:
                max = product
            
        if i-3*2 > 0 and (i-6) % 40 < i % 40:
            left_possible = True
            
        
        if i + 160 < len(random_number):
            down_possible = True
            product = 1
            for j in range(0, 160, 40):
                product *= int(random_number[i+j] + random_number[i+j+1])
            if product > max:
                max = product
        
        if right_possible and down_possible:
            product = 1
            for x,y in zip(range(0, 8, 2), range(0, 160, 40)):
                product *= int(random_number[i+x+y] + random_number[i+x+y+1])
            if product > max:
                max = product
            
        if left_possible and down_possible:
            product = 1
            for x,y in zip(range(0, -8, -2), range(0, 160, 40)):
                product *= int(random_number[i-1+x+y-1] + random_number[i-1+x+y])
            if product > max:
                max = product
                
    return max
    
    
"""
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28

Let us list the factors of the first seven triangle numbers:
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

returns the first triangle number to have over five hundred divisors
"""
def triangular_five_hundred_divisors():
    i = 1
    while True:
        num = helper.nth_triangular(i)
        div = helper.get_divisors(num)
        print(len(div))
        if len(div) >= 500:
            return num
            
        i += 1
    
    
    
# first 10 digits of a sum of 150, 50 digits numbers
def sum_ten_first_digits():
    numbers = strings.FIFTY_DIGIT_NUMBERS
    numbers = numbers.replace('\n', '')
    numbers = numbers.replace(' ', '')
    
    rows_sums = []
    for row in range(25): # calc sum of first 25 rows
        row_sum = 0
        i = row
        while i < len(numbers):
            row_sum += int(numbers[i])
            i += 50
        row_sum = str(row_sum)
        row_sum += "0" * (26-row-len(row_sum)+1)  # every row should be different length
        rows_sums.append(row_sum)
    # add up all rows together
    sum_rows = 0
    for r in rows_sums:
        sum_rows += int(r)
    return sum_rows
    
    

"""
n is the starting point
n → n/2 (n is even)
n → 3n + 1 (n is odd)
n = 13
13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
"""
def longest_collatz_sequence():
    most_chains_count = 0
    most_chains_num = 0
    for n in range(1, 1000000):
        num = n
        count = 1
        while n != 1:
            if n%2 == 0:
                n = n/2
            else:
                n = 3*n + 1
            count += 1
        if count > most_chains_count:
            most_chains_count = count
            most_chains_num = num
            print(most_chains_num, most_chains_count)
    return most_chains_num
            
            
"""
only being able to move right and down in an n*n grid
this function finds all possible routes
2*2 = 6 routes
i, j = the starting point


we know that in total we will have 40 steps to reach the finish -- 20 increases in x, 20 increases in y.

The only question is which of the 40 are the 20 increases in x.
how many different ways can you choose 20 elements out of a set of 40 elements: https://en.wikipedia.org/wiki/Binomial_coefficient
n = 40 possible pathways
k = 20 differet elements you need
n >= k >= 0
(n, k) = n! / k!*(n-k)!

40! / (20!)*(40-20)!
40!/(20!)^2
21*22...*40/(20!)
40*39*38*37*36*35*34*33*32*31*30*29*28*27*26*25*24*23*22*21/20*19*18*17*16*15*14*13*12*11*10*9*8*7*6*5*4*3*2*1
11*20*21*23*29*31*37*39

CODE OPTION:
This can be done much faster if you use dynamic programming (storing the results of subproblems rather than recomputing them).
 Dynamic programming can be applied to problems that exhibit optimal substructure - this means that an optimal solution can be constructed from optimal solutions to subproblems (credit Wikipedia).

I'd rather not give away the answer,
but consider how the number of paths to the lower right corner may be related to the number of paths to adjacent squares.

Also - if you were going to work this out by hand, how would you do it?

keep cache of each block and the amount of ways from that block till the end
block_cache = {i*j : amountOFpathPOSSIBLE}


answer = 137846528820
"""

BLOCK_CACHE = {}

def possible_routes_2d(mat, i=0, j=0, count=0):
    
    x, y = len(mat[0]), len(mat)
    
    if i == y-1 or j == x-1:
        return count + 1
    
    # go right if not calculated
    if j + 1 < x:
        if (i*x+j+1)+1 in BLOCK_CACHE:
            count += BLOCK_CACHE[i*x+j+1+1]
        else:
            block_count = possible_routes_2d(mat, i, j+1)
            BLOCK_CACHE[i*x+j+1+1] = block_count
            count += block_count
    
    # go down if not calculated
    if i + 1 < y:
        if (i+1)*x+j+1 in BLOCK_CACHE:
            count += BLOCK_CACHE[(i+1)*x+j+1]
        else:
            block_count = possible_routes_2d(mat, i+1, j)
            BLOCK_CACHE[(i+1)*x+j+1] = block_count
            count += block_count
            
    return count



# how many letters are in the words from 1 to n
import  inflect

def numbers_written_out(n=1000):
    p = inflect.engine()
    count = 0
    for i in range(1,n+1):
        words = p.number_to_words(i)
        words = words.replace('-', '')
        words = words.replace(' ', '')
        print(words)
        count += len(words)
    return count



# find the highest sum in a route from top to button in triangle of numbers
"""
    3
   7 4
  2 4 6
 8 5 9 3

starting from 1 in first row
you can either go to 1 or 1+1 on the next

n:
left = n
right = n+1


BLOCK_CACHE = {index: highest_route_sum}

triangle - list of rows   
    
triangle = strings.TRIANGLE_OF_NUMBERS
triangle = triangle[:-1].split('\n')
"""
BLOCK_CACHE = {}

def triangle_num_sum(triangle, row=0, i=0):

    if row == len(triangle)-1:
        num = int(triangle[row].split(' ')[i])
        BLOCK_CACHE[(row,i)] = num
        return num

    # current node
    path_sum = int(triangle[row].split(' ')[i])
    
    # check right
    if (row+1,i) in BLOCK_CACHE:
        right_side = BLOCK_CACHE[(row+1,i)]
    else:
        right_side = triangle_num_sum(triangle, row+1, i)
    
    # check left
    if (row+1,i+1) in BLOCK_CACHE:
        left_side = BLOCK_CACHE[(row+1,i+1)]
    else:
        left_side = triangle_num_sum(triangle, row+1, i+1)
    
    # add bigger
    if left_side > right_side:
        path_sum += left_side
    else:
        path_sum += right_side
    
    BLOCK_CACHE[(row,i)] = path_sum
    return path_sum



"""
1 Jan 1900 was a Monday.
Thirty days has September,
April, June and November.
All the rest have thirty-one,
Saving February alone,
Which has twenty-eight, rain or shine.
And on leap years, twenty-nine.
A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?

solution without using datetime
"""
def sundays_first_century():
    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    day = 2
    count = 0
    
    for year in range(1901, 2001):
        for m in months:
            print(m, year, day+1)
            
            if day == 0:
                count += 1
            
            if m == 'Sep' or m == 'Apr' or m == 'Jun' or m == 'Nov':
                day += 2
            elif m == 'Feb':
                if year % 4 == 0 and (year % 100 != 0 or (year % 100 == 0 and year % 400 == 0)):
                    day += 1
            else:
                day += 3
            day = day % 7
    return count





# returns the sum of all amicable numbers under 10000
def amicable_numbers_sum():
    amicable_numbers = []
    for i in range(1,10000):
        if i in amicable_numbers:
            continue
        divisors_sum = 0
        divs = helper.get_divisors(i)
        divs.remove(i)
        for div in divs:
            divisors_sum += div
        
        if divisors_sum == 0:
            continue
        
        redivision = 0
        divs = helper.get_divisors(divisors_sum)
        divs.remove(divisors_sum)
        for div in divs:
            redivision += div
        
        if redivision == i and i != divisors_sum:
            amicable_numbers.append(i)
            amicable_numbers.append(divisors_sum)
    amicable_numbers_sum = 0
    for i in amicable_numbers:
        amicable_numbers_sum += i
    return amicable_numbers_sum


# returns value of names.txt
def names_index_sum():
    values_sum = 0
    with open('res/names.txt', 'r') as f:
        names = f.read().split(',')
        names.sort()
        for i in range(len(names)):
            value = 0
            for c in names[i].split('"')[1].lower():
                value += ord(c) % 96
            value *= i+1
            values_sum += value
    return values_sum



"""
As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16 > 12, 
the smallest number that can be written as the sum of two abundant numbers is 24.
By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.

Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
"""
def non_abundant_sums():
    abundant_numbers = []
    for i in range(2, 28123):
        l = helper.get_divisors(i)
        l.remove(i)
        l = sum(l)
        if l > i:
            abundant_numbers.append(i)
            
    abundant_numbers_sum = [True] * 28123
    for i in abundant_numbers:
        for j in abundant_numbers:
            if i+j-1 >= len(abundant_numbers_sum):
                break
                
            if abundant_numbers_sum[i+j-1]:
                abundant_numbers_sum[i+j-1] = False
    
    all_sum = 0
    for i in range(28123):
        if abundant_numbers_sum[i]:
            print(i+1)
            all_sum += i+1
            
    return all_sum
        

# returns the index of the first term in the Fibonacci sequence to contain 1000 digits
def fib_thousand_digits():
    n = 100
    while len(str(num)) < 1000:
        
        num = helper.fib_n(n)
        n += 1
        
    return n

# returns the logenst recurring seqence for 1 divided by numbers under 1000
def recurring_cycles_fractions():
    max_sequence = 0
    max_i = 0
    
    for i in range(1, 1001):
        
        curr = helper.recurring_sequence_fraction(i)
        print(i, curr)
        if curr > max_sequence:
            max_sequence = curr
            max_i = i
            
    return max_i
    






print(recurring_cycles_fractions())









# NOT DONE - 24
"""
The lexicographic permutations of 0, 1 and 2 are:

012   021   102   120   201   210

What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?
"""
def lexicographic_permutation():
    num = "0123456789"
    for a in range(1000000):
        
        i = len(num)-1
        
        while i > 0 and int(num[i-1]) > int(num[i]):
            i -= 1
        
        num[i:] = reversed(num[i:])
        
        j = i

# NOT DONE - 696
"""
calculates the amount of possible winning cases in mahjong game given:
n: range of numbers
s: number of suits
t: required triples to win

Chow 123
Pung 111
Pair 11

winning hand 3t + 2 (3 triples * amount required +1 pair)

"""

# import itertools
def mahjong_winning_cases(n, s, t):
    possible_triples = []
    for i in range(1,n+1):
        possible_triples += [str(i)*3 + "*"]
        if i+2 <= n:
            possible_triples += [str(i)+str(i+1)+str(i+2) + "*"]

    """original_triples = possible_triples
    for i in range(s):
        for triple in original_triples:
            possible_triples += [triple + "*"]
    print(possible_triples)"""
    
    possible_pairs = n*s  # range of number times the suits
    
    # winning is any t triples + pair
    
    # can't use more than four of the same suit and number 111 red, 11 red
    possible_combinations = set(itertools.combinations(possible_triples, t))
    
    return (len(possible_combinations) * possible_pairs) - (n*s) - 1820
